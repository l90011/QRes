# -*- coding: utf-8 -*-
"""
/***************************************************************************
 ResilientIsochrones
                                 A QGIS plugin
 generating isochrones and calculating resilience values
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2023-04-28
        git sha              : $Format:%H$
        copyright            : (C) 2023 by MKS DTECH
        email                : mauro@mksdtech.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
# Standard Python libraries
import time
import json
import csv
from pathlib import Path

# Third-party libraries
import requests
import simplejson
import pyproj
import shapely.geometry
from shapely import wkt

# QGIS core libraries
from qgis.core import (
    QgsCoordinateTransform,
    QgsCoordinateReferenceSystem,
    QgsFeature,
    QgsField,
    QgsGeometry,
    QgsMarkerSymbol,
    QgsMessageLog,
    QgsPointXY,
    QgsProject,
    QgsVectorLayer,
    QgsFillSymbol,
)

# PyQt5 libraries
from PyQt5.QtCore import QSettings, QTranslator, QCoreApplication, QTimer, QVariant, Qt, QUrl
from PyQt5.QtGui import QIcon, QDesktopServices
from PyQt5.QtWidgets import (
    QAction,
    QMessageBox,
    QDialog,
    QVBoxLayout,
    QLabel,
    QLineEdit,
    QPushButton,
    QComboBox,
    QInputDialog,
    QProgressDialog,
)
from qgis.core import QgsWkbTypes
# QGIS GUI libraries
from qgis.gui import QgsMapCanvas, QgsMapToolCapture, QgsMapToolEmitPoint

# Plugin resources and dialogs
from .resources import *
from .resilient_iso_dialog import ResilientIsochronesDialog
import os.path

# Replace this with your MapBox API key
# api_key = "sk.eyJ1IjoidG9tbWFzb3R1cmNoaSIsImEiOiJjbGtsYW92bWswNHNwM3FwbDc5a2ZuYmNkIn0.FSr8J8mHrGZ1xSdyDGkINg"

# facilities = {
#     "schools": ['"amenity"="school"'],
#     "kindergarden": ['"amenity"="kindergarten"', '"amenity"="childcare"'],
#     "transportation": ['"highway"="bus_stop"', '"railway"="station"'],
#     "airports": ['"aeroway"="terminal"'],
# }

#nuove facilities

facilities = {
    "schools": ['"amenity"="school"'],
    "kindergarden": ['"amenity"="kindergarten"', '"amenity"="childcare"'],
    "transportation": ['"highway"="bus_stop"', '"railway"="station"'],
    "airports": ['"aeroway"="terminal"'],
    "leisure_and_parks": ['"leisure"="all"'],
    "shops": ['"shop"="all"'],
    "higher_education": ['"amenity"="university"'],
    "further_education": ['"amenity"="college"'],
    "hospitals": ['"healthcare"="hospital"']
}

#nuovi profili
profiles = {
    "schools": {"profile": "walking", "intervals": [5, 15, 30]},
    "kindergarden": {"profile": "walking", "intervals": [5, 15, 30]},
    "transportation": {"profile": "walking", "intervals": [5, 15, 30]},
    "airports": {"profile": "driving", "intervals": [15, 30, 60]},
    "leisure_and_parks": {"profile": "walking", "intervals": [5, 15, 30]},  # valori intervalli da definire
    "shops": {"profile": "walking", "intervals": [5, 15, 30]},  # valori intervalli da definire
    "higher_education": {"profile": "walking", "intervals": [5, 15, 30]},  # valori intervalli da definire
    "further_education": {"profile": "walking", "intervals": [5, 15, 30]},  # valori intervalli da definire
    "hospitals": {"profile": "driving", "intervals": [15, 30, 60]},  # valori intervalli da definire
}

# profiles = {
#     "schools": {"profile": "walking", "intervals": [5, 15, 30]},
#     "kindergarden": {"profile": "walking", "intervals": [5, 15, 30]},
#     "transportation": {"profile": "walking", "intervals": [5, 15, 30]},
#     "airports": {"profile": "driving", "intervals": [15, 30, 60]},
# }

class ApiKeyDialog(QDialog):
    def __init__(self, parent=None):
        super(ApiKeyDialog, self).__init__(parent)

        layout = QVBoxLayout()

        self.label = QLabel("Please enter your API Key:")
        layout.addWidget(self.label)

        self.lineEdit = QLineEdit()
        layout.addWidget(self.lineEdit)

        self.noteLabel = QLabel("Note: You can get your API Key from:")
        layout.addWidget(self.noteLabel)

        self.linkLabel = QLabel('<a href="https://docs.mapbox.com/help/getting-started/access-tokens/">www.mapbox.com</a>')
        self.linkLabel.setOpenExternalLinks(True)
        layout.addWidget(self.linkLabel)

        self.button = QPushButton("OK")
        layout.addWidget(self.button)

        self.button.clicked.connect(self.accept)

        self.setLayout(layout)

class ResilientIsochrones:
    class ResilientIsochronesDialog(QDialog):
        def __init__(self, parent=None):
            super(ResilientIsochronesDialog, self).__init__(parent)

            # Get the directory of the current python script
            script_dir = os.path.dirname(os.path.realpath(__file__))
            # Construct the full path to the UI file
            ui_path = os.path.join(script_dir, "resilient_iso_dialog_base.ui")

            uic.loadUi(ui_path, self)
            self.layersComboBox = self.findChild(QComboBox, "layersComboBox")

    """QGIS Plugin Implementation."""

    def __init__(self, iface):
        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        # Load the UI file
        self.dlg = ResilientIsochronesDialog()
        # Save reference to the QGIS interface
        self.iface = iface

        # Initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)
        # Initialize locale
        locale = QSettings().value("locale/userLocale")[0:2]
        locale_path = os.path.join(
            self.plugin_dir, "i18n", f"ResilientIsochrones_{locale}.qm"
        )

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)
            QCoreApplication.installTranslator(self.translator)

        # Declare instance attributes
        self.actions = []
        self.menu = self.tr("&ResilientIsochrones")

        # Check if plugin was started the first time in current QGIS session
        # Must be set in initGui() to survive plugin reloads
        self.first_start = None

    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate("ResilientIsochrones", message)

    def add_action(
        self,
        icon_path,
        text,
        callback,
        enabled_flag=True,
        add_to_menu=True,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None,
        parent=None,
    ):
        """Add a toolbar icon to the toolbar.

        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :type icon_path: str

        :param text: Text that should be shown in menu items for this action.
        :type text: str

        :param callback: Function to be called when the action is triggered.
        :type callback: function

        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool

        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool

        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool

        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str

        :param parent: Parent widget for the new action. Defaults None.
        :type parent: QWidget

        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.

        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        """

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            # Adds plugin icon to Plugins toolbar
            self.iface.addToolBarIcon(action)

        if add_to_menu:
            self.iface.addPluginToMenu(self.menu, action)

        self.actions.append(action)

        return action

    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""

        icon_path = ":/plugins/resilient_iso/icon.png"
        self.add_action(
            icon_path,
            text=self.tr("generating isochrones and calculating resilience values"),
            callback=self.run,
            parent=self.iface.mainWindow(),
        )

        # Will be set False in run()
        self.first_start = True

    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""
        for action in self.actions:
            self.iface.removePluginMenu(self.tr("&ResilientIsochrones"), action)
            self.iface.removeToolBarIcon(action)

    def run(self):
        """Run method that performs all the real work"""
            
        settings = QSettings()
        api_key = settings.value("ResilienceMapper1/api_key", "")

        if not api_key:
            dialog = ApiKeyDialog(self.iface.mainWindow())
            result = dialog.exec_()

            if result == QDialog.Accepted:
                api_key = dialog.lineEdit.text()
                settings.setValue("ResilienceMapper1/api_key", api_key)
            else:
                QMessageBox.information(
                    self.iface.mainWindow(),
                    "Operation Canceled",
                    "The operation was canceled by the user."
                )
                return

        # Clear all items in the combo box
        self.dlg.layersComboBox.clear()

        # Get all layers from the current QGIS project and filter them
        layers = []
        for layer in QgsProject.instance().mapLayers().values():
            if isinstance(layer, QgsVectorLayer):  # Make sure it's a vector layer
                if layer.geometryType() == QgsWkbTypes.PointGeometry:
                    layers.append(layer.name())

        # Add all layers to the combo box
        self.dlg.layersComboBox.addItems(layers)

        # Show the dialog
        result = self.dlg.exec_()

        if result != QDialog.Accepted:
            # User closed the dialog or pressed Cancel
            QMessageBox.information(
                self.iface.mainWindow(),
                "Operation Canceled",
                "The operation was canceled by the user.",
            )
            return
        
        # Get the selected layer name
        selected_layer_name = self.dlg.layersComboBox.currentText()

        # Get the selected layer object
        self.point_layer = QgsProject.instance().mapLayersByName(selected_layer_name)[0]
        
        # Initialize QProgressDialog
        total_operations = len(facilities) + self.point_layer.featureCount()
        progressDialog = QProgressDialog("Processing...", "Cancel", 0, total_operations, self.iface.mainWindow())
        progressDialog.setWindowModality(Qt.WindowModal)
        progressDialog.setWindowTitle("Processing...")
        progressDialog.show() 

        # Initialize progress counter
        progressCounter = 0

        # Enable editing mode for the point layer
        self.point_layer.startEditing()

        existing_field_names = [field.name() for field in self.point_layer.fields()]

        # Add the new fields for X and Y coordinates to the layer only if they do not exist
        if "X_coord" not in existing_field_names:
            self.point_layer.dataProvider().addAttributes(
                [QgsField("X_coord", QVariant.Double)]
            )

        if "Y_coord" not in existing_field_names:
            self.point_layer.dataProvider().addAttributes(
                [QgsField("Y_coord", QVariant.Double)]
            )

        # Add the new fields to the layer only if they do not exist
        for facility_key in facilities.keys():
            if f"R_{facility_key}" not in existing_field_names:
                self.point_layer.dataProvider().addAttributes(
                    [QgsField(f"R_{facility_key}", QVariant.Double)]
                )

        if "R_total" not in existing_field_names:
            self.point_layer.dataProvider().addAttributes(
                [QgsField("R_total", QVariant.Double)]
            )

        # Update the fields
        self.point_layer.updateFields()

        layer_crs = self.point_layer.crs()

        # Check if the layer's CRS is not WGS84 (EPSG:4326)
        if layer_crs.authid() != "EPSG:4326":
            # Create a coordinate transformer object
            transform = QgsCoordinateTransform(layer_crs, QgsCoordinateReferenceSystem(4326), QgsProject.instance())

        # Loop through points to calculate resilience
        for feature in self.point_layer.getFeatures():
            if progressDialog.wasCanceled():
                break
            if feature.geometry().isNull():
                continue

            point = feature.geometry().asPoint()

            # Transform the point if needed
            if layer_crs.authid() != "EPSG:4326":
                point = transform.transform(point)

            resilience_dict = calculate_resilience(point, facilities, profiles, api_key)

            # Update the attributes with the calculated resilience values
            feature_id = feature.id()
            for key, value in resilience_dict.items():
                attribute_index = self.point_layer.fields().indexOf(key)
                self.point_layer.dataProvider().changeAttributeValues(
                    {feature_id: {attribute_index: value}}
                )

            # Update the X and Y coordinate attributes
            x_index = self.point_layer.fields().indexOf("X_coord")
            y_index = self.point_layer.fields().indexOf("Y_coord")
            self.point_layer.dataProvider().changeAttributeValues(
                {feature_id: {x_index: point.x(), y_index: point.y()}}
            )
            # Update ProgressDialog
            progressCounter += 1
            progressDialog.setValue(progressCounter)
            QCoreApplication.processEvents()
            progressDialog.setLabelText(f"Calculating resilience for point {feature.id()}")
        
        # Commit changes
        self.point_layer.commitChanges()

        # Update the layer
        self.point_layer.triggerRepaint()

        # Close the progress dialog
        progressDialog.reset()

        # Show operation complete dialog
        QMessageBox.information(
            self.iface.mainWindow(), "Operation Complete", "The operation is complete."
        )

 # Define the resilience calculation function
def calculate_resilience(point, facilities, profiles, api_key):
    latitude = point.y()
    longitude = point.x()
    new_coordinates = [longitude, latitude]
    resilience_dict = {}

    for facility_key in facilities.keys():
        profile = profiles[facility_key]["profile"]
        intervals = profiles[facility_key]["intervals"]
        isochrones_features = create_isochrones(api_key, new_coordinates, intervals, profile, facility_key)
        isochrone_wkts = [shapely.geometry.shape(feature["geometry"]).wkt for feature in isochrones_features]
        
        all_facilities = []
        for wkt in isochrone_wkts:
            polygon = wkt_polygon_to_overpass_format(wkt)
            for query in facilities[facility_key]:
                all_facilities = [set(get_osm_data_within_polygon(polygon, query))] + all_facilities

        for i in range(len(isochrone_wkts)):
            for j in range(i + 1, len(isochrone_wkts)):
                all_facilities[j] = all_facilities[j] - all_facilities[i]

        N = [len(facilities) for facilities in all_facilities]
        R = N[0] * 1 + N[1] * 0.75 + N[2] * 0.5
        resilience_dict[f"R_{facility_key}"] = R

    resilience_dict["R_total"] = sum(resilience_dict.values()) / len(resilience_dict)
    return resilience_dict

def wkt_polygon_to_overpass_format(wkt_polygon):
    polygon_coordinates_str = wkt_polygon.split("((")[1].split("))")[0]
    polygon_coordinates_pairs = polygon_coordinates_str.split(", ")
    overpass_coordinates_pairs = [
        pair.split(" ")[::-1] for pair in polygon_coordinates_pairs
    ]
    overpass_format_polygon = " ".join(
        [" ".join(pair) for pair in overpass_coordinates_pairs]
    )
    return overpass_format_polygon

def get_osm_data_within_polygon(polygon_wkt, query):
    url = "http://overpass-api.de/api/interpreter"
    query = f"""
[out:json];
(
    node[{query}](poly:"{polygon_wkt}");
    way[{query}](poly:"{polygon_wkt}");
    relation[{query}](poly:"{polygon_wkt}");
);
out body;
>;
out skel qt;
""".strip()

    response = requests.get(url, params={"data": query})

    if response.status_code != 200:
        print(f"Request failed with status code {response.status_code}.SCHOOLS")
        return []
    try:
        # print(response.text)  # Add this line to print the response text
        data = response.json()
        # Extract school names from the JSON data
        schools = [
            elem["tags"]["name"]
            for elem in data["elements"]
            if "tags" in elem and "name" in elem["tags"]
        ]
        return schools
    except simplejson.errors.JSONDecodeError as e:
        print(f"JSONDecodeError: {e}")
        return []


def create_isochrones(api_key, coordinates, intervals, profile, facility_type):
    print(f"Selected profile: {profile}")
    try:
        # Construct the URL for the Mapbox Isochrone API
        url = f"https://api.mapbox.com/isochrone/v1/mapbox/{profile}/{coordinates[0]},{coordinates[1]}"

        # Add the contours_minutes parameter to the URL
        url += "?contours_minutes=" + ",".join(map(str, intervals))

        # Add the polygons parameter to the URL
        url += "&polygons=true"

        # Add the access token to the URL
        url += f"&access_token={api_key}"

        # Send a GET request to the Isochrone API
        response = requests.get(url)

        # Parse the JSON response
        data = json.loads(response.text)

        # print(response)
        if "features" in data:
            print("Isochrones successfully created!")
            features = data["features"]
            return features  # Return the isochrone features
        else:
            print(f"Error: {data['message']}")
    except requests.exceptions.RequestException as e:
        print(f"RequestException: {e}")
    except Exception as e:
        print(f"Exception: {e}")
    return []
